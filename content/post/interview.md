---
title: "Interview"
date: 2020-02-26T18:55:13+08:00
draft: true
---


## 计算机网络

* TCP三次握手和四次挥手

![1](1.png)

1、客户端发送请求报文，设置标志位SYN=1,客户端进入SYN_SNET状态
2、服务端接收发现是SYN后设置SYN=1和ACK=1，server端进入SYN_RCVD
3、客户端发送ACK给服务端

![2](2.png)

1、client发送FIN到服务端进入FIN_WAIT状态
2、server发送ACK，进入CLOSE_WAIT状态
3、server发送一个FIN，进入LAST_ACK状态
4、client发送一个ACK


* 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

因为client发送FIN请求断开连接，server可能还有数据要发，所以先发一个ACK确认收到了client的FIN，然后要等server把数据发完再发一个FIN

* 为什么是三次握手而不是两次

防止server端收到过期的同步请求而直接建立连接导致服务器浪费资源

* 握手时产生的序列号干什么用的

用于标识发送的数据流，为什么是随机开始的，防止被篡改

* 讲一下发送窗口，接收窗口

发送窗口是有发送方维护的控制发送数据大小的的值
接收窗口时接收方维护的接收数据大小的值

* TCP和UDP的本质区别

TCP是面向连接的，要客户端和服务端建立逻辑连接才能发送数据，它保证数据尽可能尽快的从发送方到接收方
UDP是面向报文的，他只负责发送数据，进最大努力发送

TCP的头部开销为20字节，而UDP只有8字节，UDP开销小

* 什么时候选择TCP/UDP

UDP
不在乎传输完整性，只在乎效率，比如音视频

TCP
在乎数据完整性，
比如HTTP协议

* HTTPS的连接过程

1、客户端发送会话请求
2、服务端发送公钥
3、客户端验证证书是否可信
4、客户端生成随机对称密钥，并用服务端的公钥加密后发给服务端
5、客户端要发送数据就用随机密钥加密后再发送
6、服务端要发送数据就用公钥加密后发送

* OSI模型

1、物理层
2、数据链路层
3、网络层
IP
4、传输层
TCP、UDP
5、会话层
6、表达层
7、应用层
HTTP，FTP，SMTP

* TCP/IP模型

1、连接层
以太网、ADSL
2、网络层
IP
3、传输层
TCP、UDP
4、应用层
HTTP、HTTPS

* HTTPS怎么确认收到的包就是服务器发来的

数字证书

* 输入url之后发生的所有事情

1、想DNS服务器请求域名IP
2、建立TCP连接
3、发送HTTP请求
4、服务端处理请求
5、返回响应结果
6、关闭TCP连接
7、浏览器解析HTML
8、浏览器渲染HTML



## 数据库

* 事务的四大特性

1、原子性
最小的操作，要么全部成功，要么全部失败
2、一致性
3、隔离性
事务之间相互隔离
4、持久性
事务的提交是永久的

* 事务的隔离级别

并发事务同时访问数据表出现的问题
1、脏读
一个事务读取了另一个未提交的事务的数据
2、不可重复读
一个事务多次查询返回了不同的结果（原因是读的过程有另一个事务修改并提交了
3、幻读
事务1通过一条where语句读取数据，然后事务2插入或者修改了数据使某些新纪录恰好满足事务1的的where条件，导致事务1的结果里出现了事务2的记录。

不可重复读和幻读的区别
不可重复读是针对一条数据，幻读针对的是一批数据

隔离级别
1、读未提交
可以读取另一个事务未提交的数据。这个阶段运行脏读、不可重复读、幻读
2、读已提交
一个事务要等另一个事务提交后才能读取数据。不允许脏读，允许不重复读和换读
3、可重复读
开始读取操作时，不允许修改操作
4、可串行化
事务串行化顺序执行

* InnoDB 怎么防止幻读

对读取到的记录加锁同时保证对读取的范围加锁

* redis数据类型

string
list
set
hash
sorted
set
HyperLogLog

## 操作系统

* 用户态、内核态，为什么要分开

用户态
上层应用程序的运行空间
内核态
控制计算机硬件资源并提供给上层应用程序

为什么要分开
防止某些危险指令被滥用导致系统频繁崩溃

* 用户态如何切换到内核态

1、中断
2、异常
3、系统调用

* 进程间通信的方式，哪种最快

1、管道：速度慢，容量有限
2、消息队列
3、信号量
4、共享内存

* 进程、线程、携程、goroutine

进程
操作系统资源分配的最小单元，一个进程相当于一个程序的执行过程
线程
进程内部参与任务执行的最小单元，线程是cpu调度的最小单元，线程共享进程的大部分资源
协程
协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。
goroutine
本质上，goroutine 就是协程。但是Golang对goroutine的调度进行了封装


## 语言

* 什么是Python生成器，迭代器；
迭代器可以用于迭代操作的对象，他和列表的区别是他只记录当前迭代的位置，而不把所有数据加入内存

生成器
生成迭代器的函数

* 什么是装饰器

用与装饰函数对象，

* 元组和list的区别

元组是不可变对象
list是可变对象

* python dict怎么实现的

hash表











