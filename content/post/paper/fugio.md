---
title: "FUGIO: Automatic Exploit Generation for PHP Object Injection Vulnerabilities"
date: 2023-04-18T10:18:41+08:00
showDate: true
draft: false
tags: ["security","vulnerabilities", "code"]
categories: ["security"]
---

## 0x01 前言

今天给大家分享一篇论文FUGIO: Automatic Exploit Generation for PHP Object Injection Vulnerabilities，通过静态分析和动态分析找到POP链，再通过FUZZ生成exp。


## 0x02 POI & POP Chain

我们先来回顾一下PHP对象注入和POP链。

![1.png](1.png)

上图左边这段代码，这个vuln.php接受了一个get参数data，这个data会经过反序列化函数。这个反序列化就是不安全的反序列化，当攻击者提交这个data参数的时候，这个data的值会被反序列化成Example1对象，然后它的属性值cache_file会设置为../../index.php。然后当这个对象的生命周期结束的时候，会自动调用__destruct函数，这里就会导致一个任意文件删除。这个就是一个PHP对象注入漏洞。

![2.png](2.png)


那么对于一个对象注入漏洞，正常情况下肯定不会像刚刚的代码那么简单，直接在魔术方法里执行敏感操作。

我们看这个稍微复杂一点的例子，这里的魔术方法里看起来是安全的，没有调用什么危险函数，但是，当我们传入右边这个字符串的时候，我们让logger对象的log属性值变成了TempFile对象，然后logtype属性的值变成TEMPORARY，还是会触发任意文件删除。然后a图的触发链就被称为POP链，它指的是从source也就是魔术方法到target也就是sink函数的一个执行链。

## 0x03 本文动机

首先，现有的一些工具，对于POI漏洞，目前只能做到检测是否可能存在POI漏洞，但是对于漏洞的二次确认可能还需要安全专业来参与，那么作者的目的就是提出一个可以自动检测POI漏洞然后自动生成漏洞利用的一个工具，漏洞利用作为一个凭据，就不需要安全专业进行二次确认了。

![3.png](3.png)

## 0x04 挑战

为了作者这么一个工具，作者提出了几个需要实现的目标，以及相应的挑战。

我们刚刚也提到了，对于找POI漏洞点，目前已经可以做到而且很成熟了。所以主要是针对下面两个目标。

对于第二个目标，它的挑战是

首先PHP是动态语言，他有些类是动态加载的，并不存在于源代码里，那么应该如何能识别所有的类就是一个挑战。

其次，我们刚刚介绍的POP链只是一个简单的例子，真实的应用常见可能有几十万行代码，几万个类，怎么能找到一条从魔术方法到sink函数的POP链也是一个问题


对于第三个目标

当PHP程序很大的时候，FUZZ很难有很高的吞吐量，执行一条FUZZ可能需要几百毫秒，那就没办法做到高效的FUZZ。

此外，FUZZ一般都面向字节流来进行的，这里的FUZZ可能需要针对类的属性进行变异。

![4.png](4.png)

## 0x05 贡献

于是，作者就设计了这么一个自动化利用POI漏洞的工具。

它的贡献如下

- 提出了FUGIO，一种识别POI漏洞并生成漏洞利用的AEG工具

- 提出了一种深度受限的广度优先搜索方法来查找POP链

- 提出了一种反馈驱动的FUZZ来生成exploit


## 0x06 框架设计

针对上面的目标和挑战，作者提出了它的方法和设计思路。首先我们看一下FUGIO的架构和工作流。

从工作流我们可以看到，FGUIO分为五个组件，这五个组件我们待会儿详细介绍。从总体来看，它以应用的源码以及应用的URL作为输入，经过五个组件之后，得到一个exploit，也就是漏洞利用。

![5.png](5.png)

## 0x07 POI Detector

这个组件的作用就是对POI漏洞进行一个检测，看是否存在潜在的POI漏洞。

它的做法就是首先通过HOOK的方式，对26个反序列化相关的函数比如unserialize,is_file,file_exists等进行hook，然后提交一个预定义的字符串看是否会触发反序列化相关的函数，如果函数被出发，因为这些函数都被hook了，所以我们可以拿到一些运行信息，然后也知道他可能存在POI漏洞。

![6.png](6.png)

## 0x08 Static Analyzer & Dynamic Analyzer

对于静态分析器和动态分析器主要是对代码进行一个分析，然后获取到源代码里所有的类和函数的摘要信息，用于我们后面的POP链构造。


![7.png](7.png)

## 0x09 POP Chain Identifier

对于POP Chain  Identifier器它的作用就是找到能从魔术方法到sink函数的POP链。

### 构造树

为了找到一条POP链，它的做法是通过分析器得到的类和代码的摘要，来构造出深度受限的一棵调用树，这个调用树的根节点就是sink函数的调用者。对于每个节点，它的子节点就是它的潜在调用者。

我们看右边这个图，他就是刚刚我们POP那个例子unlink函数的调用树。

根节点是unlink函数的调用者Tempfile::close，然后它的子节点就是调用了close的一些函数或者方法，比如这里的Steam::close。

然后因为是深度受限的调用树，作者把深度设置为一个超参数，后面会对这个超参数进行探究。


![8.png](8.png)

### 调用链

得到了这颗调用树之后，通过广度优先搜索，我们就可以找到从sink函数到魔术方法的一个反向查找，也就算找到了一条POP链。

![9.png](9.png)

### PUT生成

然后POP Chain Identifier还有一个作用，就是生成一个PUT，这个PUT可以理解成一个包含所有触发POP Chain需要的类的一个最小化的虚拟环境，它的作用就是解决我们前面的FUZZ性能不高的挑战。


## POP Chain Fuzzer

这个POP Chain Fuzzer的作用其实就是给定一个PUT和一条POP链，来进行一个FUZZ。

我们先看左边大概的流程，首先，初始化一个seed，这个seed包含的是POP链包含魔术方法的那个类，然后经过变异之后得到一个新的输入，这个输入执行之后根据它的返回结果又添加新的Seed，直到找到一个可用的漏洞利用。

![10.png](10.png)


对于右边的算法，还有几个值得注意的点。
首先是这个selectSeed函数(第七行)，它的作用是从seed池里选一个seed，它更有可能会选择能够达到更深的POP链而且被选择的次数更少的seed。

此外对于MutateSeed函数(第八行)，它是通过seed构造出一个模板，通过这个模板来生成一个input，下图就是图二代码生成input模板的代码。

![11.png](11.png)

## 0x10 实验评估

下面是作者的实验评估

作者在30个PHP应用程序上对FUGIO评估。对于每一个应用， 作者手动准备了一个一种的POI漏洞插入程序中。对于每个应用，作者进行五次fuzzing，每次fuzzing持续12个小时。下面这个表总结了评估结果，第三列就是识别出来的链，第四列就是fuzz过的chain的数量，覆盖的sink就表示sink函数的数量。中括号里分别是最大值和最小值，小括号里的是五次实验加起来之后去重得到的最大chain数量。True Positive Chain就是手动确认的数量。最后两列是时间消耗。

![12.png](12.png)


最终的实验结果，FUGIO找到了68条可利用的POP链，且不存在假阳性。66条可能的POP链，手动确认之后有26条可利用的。

然后是FUGIO和SOTA的方法进行对比的实验

![13.png](13.png)

![14.png](14.png)


### 超参数

作者还评估了两个超参数，一个是fuzzing的超时时间，一个是最大chain的长度，也就是调用树的最大深度。

![15.png](15.png)

### 实际测试

最后作者对于两个最新版本PHP应用进行测试：WordPress 5.4.2 with WooCommerce and Concrete5 8.5.4。WP中挖到了一个任意函数调用，Concrete5挖到了一个任意文件删除。

最后他把漏洞和漏洞利用报告给了HackerOne，Wordpress团队报告了这个漏洞但是没有披露细节，Concrete5团队为漏洞分配了一个CVE-2021-40102